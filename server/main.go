package main

import (
	"encoding/json"
	"log"
	"net/http"
	"path"
	"strings"

	_ "github.com/jackc/pgx/stdlib"
	"github.com/jmoiron/sqlx"
)

var db *sqlx.DB

func main() {
	var err error
	// connect to db TODO: read dbname from .ini
	db, err = sqlx.Connect("pgx", "dbname=whichdb")
	if err != nil {
		log.Fatalf("Unable to establish connection to the database: %v\n", err)
	}
	defer db.Close()

	rh := &RootHandler{
		StaticHandler: new(StaticHandler),
	}
	http.ListenAndServe(":8080", rh)
}

// handlers

type RootHandler struct {
	StaticHandler    *StaticHandler
	QuestionsHandler *QuestionsHandler
}

func (handler *RootHandler) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	head, tail := ShiftPath(req.URL.Path)
	if head == "qs" {
		req.URL.Path = tail
		handler.QuestionsHandler.ServeHTTP(resp, req)
	} else {
		handler.StaticHandler.ServeHTTP(resp, req)
	}
}

// StaticHandler serves files generated by Svelte (in /public)
type StaticHandler struct{}

func (handler *StaticHandler) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	if req.URL.Path == "/" {
		http.ServeFile(resp, req, "public/index.html")
	} else {
		http.ServeFile(resp, req, "public"+req.URL.Path)
	}
}

type QuestionsHandler struct{}

func (handler *QuestionsHandler) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	questions, err := fetchQuestions()
	if err != nil {
		log.Fatalf("Unable to fetch questions from db: %v\n", err)
	}
	if err = json.NewEncoder(resp).Encode(questions); err != nil {
		log.Fatalf("Unable to encode questions as JSON: %v\n", err)
	}
}

// from https://blog.merovius.de
// ShiftPath returns ("a", "/b/c") given "/a/b/c/"
func ShiftPath(p string) (head, tail string) {
	p = path.Clean("/" + p)
	i := strings.Index(p[1:], "/") + 1
	if i <= 0 {
		return p[1:], "/"
	}
	return p[1:i], p[i:]
}
