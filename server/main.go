package main

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path"
	"strings"
	"time"

	"golang.org/x/oauth2"
	"golang.org/x/oauth2/google"

	_ "github.com/jackc/pgx/stdlib"
	"github.com/jmoiron/sqlx"
)

// TODO: read these from a config file
const (
	oauthGoogleUrlAPI = "https://www.googleapis.com/oauth2/v2/userinfo?access_token="
	cookieDuration    = 24 * time.Hour
)

var (
	db               *sqlx.DB
	googleAuthConfig *oauth2.Config
)

func init() {
	var err error
	// set up oauth config
	googleAuthConfig = &oauth2.Config{
		RedirectURL:  "http://localhost:8080/auth/callback",
		ClientID:     os.Getenv("WHICH_GOOGLE_CLIENT_ID"),
		ClientSecret: os.Getenv("WHICH_GOOGLE_CLIENT_SECRET"),
		Scopes:       []string{"https://www.googleapis.com/auth/userinfo.email"},
		Endpoint:     google.Endpoint,
	}

	// connect to db
	db, err = sqlx.Connect("pgx", os.Getenv("WHICH_DB_STRING"))
	if err != nil {
		log.Fatalf("Unable to establish connection to the database: %v\n", err)
	}
}

func main() {
	defer db.Close()
	rh := &RootHandler{
		StaticHandler:    new(StaticHandler),
		QuestionsHandler: new(QuestionsHandler),
		AuthHandler:      new(AuthHandler),
	}
	http.ListenAndServe(":8080", rh)
}

// handlers TODO: break out into separate file(s)

type RootHandler struct {
	StaticHandler    *StaticHandler
	QuestionsHandler *QuestionsHandler
	AuthHandler      *AuthHandler
}

func (handler *RootHandler) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	head, tail := shiftPath(req.URL.Path)
	if head == "qs" {
		req.URL.Path = tail
		handler.QuestionsHandler.ServeHTTP(resp, req)
	} else if head == "auth" {
		req.URL.Path = tail
		handler.AuthHandler.ServeHTTP(resp, req)
	} else {
		handler.StaticHandler.ServeHTTP(resp, req)
	}
}

type AuthHandler struct {
	LoginHandler    *LoginHandler
	CallbackHandler *CallbackHandler
}

func (handler *AuthHandler) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	head, _ := shiftPath(req.URL.Path)
	if head == "login" {
		log.Printf("AuthHandler: %v\n", handler)
		handler.LoginHandler.ServeHTTP(resp, req) // TODO: req URL correct?
	} else if head == "callback" {
		handler.CallbackHandler.ServeHTTP(resp, req)
	} else {
		http.Error(resp, "auth endpoint does not exist", 404)
	}
}

type LoginHandler struct{}

func (handler *LoginHandler) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	stateString, err := randomStateString()
	if err != nil {
		log.Fatalf("Unable to generate random state string: %v\n", err)
	}
	addCookie(resp, "state", stateString, cookieDuration)
	url := googleAuthConfig.AuthCodeURL(stateString)
	http.Redirect(resp, req, url, http.StatusTemporaryRedirect)
}

type CallbackHandler struct{}

func (handler *CallbackHandler) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	stateCookie, err := req.Cookie("state")
	if err != nil {
		log.Printf("Auth callback missing cookie: %v\n", err)
		http.Redirect(resp, req, "/", http.StatusTemporaryRedirect)
	}
	if req.FormValue("state") != stateCookie.Value {
		// TODO: alert user to possible CSRF attack?
		http.Redirect(resp, req, "/", http.StatusTemporaryRedirect)
	} else { // cookie matches state, proceed
		data, err := getUserData(req.FormValue("code"))
		if err != nil {
			log.Println(err.Error())
			http.Redirect(resp, req, "/", http.StatusTemporaryRedirect)
		} else {
			log.Printf("UserInfo: %s\n", data)
			fmt.Fprintf(resp, "UserInfo: %s\n", data)
		}
	}
}

func getUserData(authCode string) ([]byte, error) {
	// TODO: context.Background() ???
	token, err := googleAuthConfig.Exchange(context.Background(), authCode)
	if err != nil {
		return nil, fmt.Errorf("failed to exchange code for token: %s", err.Error())
	}
	response, err := http.Get(oauthGoogleUrlAPI + token.AccessToken)
	if err != nil {
		return nil, fmt.Errorf("failed to get userinfo from Google Oauth: %s", err.Error())
	}
	defer response.Body.Close()
	data, err := ioutil.ReadAll(response.Body) // TODO: improve this?  why using ioutil.ReadAll?
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %s", err.Error())
	}
	return data, nil
}

// randomStateString returns a b64 string with 32 bytes of randomosity
// TODO: consider removing error return and crashing on failure (shouldn't happen)
func randomStateString() (string, error) {
	bytes := make([]byte, 32)
	_, err := rand.Read(bytes)
	if err != nil {
		return "", err
	}
	return base64.URLEncoding.EncodeToString(bytes), nil
}

// StaticHandler serves files generated by Svelte (in /public)
type StaticHandler struct{}

func (handler *StaticHandler) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	if req.URL.Path == "/" {
		http.ServeFile(resp, req, "public/index.html")
	} else {
		http.ServeFile(resp, req, "public"+req.URL.Path)
		// TODO: consider explicitly sending 404 if resources doesn't exist
	}
}

// QuestionsHandler calls fetchQuestions in db.go and writes the response as JSON
type QuestionsHandler struct{}

func (handler *QuestionsHandler) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	questions, err := fetchQuestions()
	if err != nil {
		log.Fatalf("Unable to fetch questions from db: %v\n", err)
		http.Error(resp, "unable to fetch questions from database", 500) // TODO: more precise error
	}
	if err = json.NewEncoder(resp).Encode(questions); err != nil {
		log.Fatalf("Unable to encode questions as JSON: %v\n", err)
		// TODO: this shouldn't fail, but if it does, what does the client see?
	}
}

// from https://blog.merovius.de
// shiftPath returns ("a", "/b/c") given "/a/b/c/"
func shiftPath(p string) (head, tail string) {
	p = path.Clean("/" + p)
	i := strings.Index(p[1:], "/") + 1
	if i <= 0 {
		return p[1:], "/"
	}
	return p[1:i], p[i:]
}

func addCookie(resp http.ResponseWriter, name string, value string, duration time.Duration) {
	expires := time.Now().Add(duration)
	cookie := http.Cookie{
		Name:    name,
		Value:   value,
		Expires: expires,
	}
	http.SetCookie(resp, &cookie)
}
