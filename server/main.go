package main

// TODO: cut down on all the log.Fatal

import (
	"encoding/json"
	"log"
	"net/http"
	"os"
	"path"
	"strings"
	"time"

	"golang.org/x/oauth2"
	"golang.org/x/oauth2/google"

	_ "github.com/jackc/pgx/stdlib"
	"github.com/jmoiron/sqlx"
)

// TODO: read these from a config file
const (
	oauthGoogleUrlAPI = "https://www.googleapis.com/oauth2/v2/userinfo?access_token="
	cookieDuration    = 24 * time.Hour
)

var (
	db               *sqlx.DB
	googleAuthConfig *oauth2.Config
)

func init() {
	log.SetFlags(log.Lshortfile | log.LstdFlags)
	var err error
	// set up oauth config
	googleAuthConfig = &oauth2.Config{
		RedirectURL:  "http://localhost:8080/auth/callback",
		ClientID:     os.Getenv("WHICH_GOOGLE_CLIENT_ID"),
		ClientSecret: os.Getenv("WHICH_GOOGLE_CLIENT_SECRET"),
		Scopes:       []string{"https://www.googleapis.com/auth/userinfo.email"},
		Endpoint:     google.Endpoint,
	}

	// connect to db
	db, err = sqlx.Connect("pgx", os.Getenv("WHICH_DB_STRING"))
	if err != nil {
		log.Fatalf("Unable to establish connection to the database: %v\n", err)
	}
}

func main() {
	defer db.Close()
	rh := &RootHandler{
		StaticHandler:    new(StaticHandler),
		QuestionsHandler: new(QuestionsHandler),
		AuthHandler:      new(AuthHandler),
	}
	/*err := createUser(userInfo{ID: "testid", Email: "testemail"})
	if err != nil {
		log.Fatalf("%v\n", err)
	}*/
	http.ListenAndServe(":8080", rh)
}

// handlers TODO: break out into separate file(s)

type RootHandler struct {
	StaticHandler    *StaticHandler
	QuestionsHandler *QuestionsHandler
	AuthHandler      *AuthHandler
}

func (handler *RootHandler) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	head, tail := shiftPath(req.URL.Path)
	if head == "qs" {
		req.URL.Path = tail
		handler.QuestionsHandler.ServeHTTP(resp, req)
	} else if head == "auth" {
		req.URL.Path = tail
		handler.AuthHandler.ServeHTTP(resp, req)
	} else {
		handler.StaticHandler.ServeHTTP(resp, req)
	}
}

// StaticHandler serves files generated by Svelte (in /public)
type StaticHandler struct{}

func (handler *StaticHandler) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	if req.URL.Path == "/" {
		http.ServeFile(resp, req, "public/index.html")
	} else {
		http.ServeFile(resp, req, "public"+req.URL.Path)
		// TODO: consider explicitly sending 404 if resources doesn't exist
	}
}

// QuestionsHandler calls fetchQuestions in db.go and writes the response as JSON
type QuestionsHandler struct{}

func (handler *QuestionsHandler) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	questions, err := fetchQuestions()
	if err != nil {
		log.Fatalf("Unable to fetch questions from db: %v\n", err)
		http.Error(resp, "unable to fetch questions from database", 500) // TODO: more precise error
	}
	if err = json.NewEncoder(resp).Encode(questions); err != nil {
		log.Fatalf("Unable to encode questions as JSON: %v\n", err)
		// TODO: this shouldn't fail, but if it does, what does the client see?
	}
}

// from https://blog.merovius.de
// shiftPath returns ("a", "/b/c") given "/a/b/c/"
func shiftPath(p string) (head, tail string) {
	p = path.Clean("/" + p)
	i := strings.Index(p[1:], "/") + 1
	if i <= 0 {
		return p[1:], "/"
	}
	return p[1:i], p[i:]
}

func addCookie(resp http.ResponseWriter, name string, value string, duration time.Duration) {
	expires := time.Now().Add(duration)
	cookie := http.Cookie{
		Name:    name,
		Value:   value,
		Expires: expires,
	}
	http.SetCookie(resp, &cookie)
}
